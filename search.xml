<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode双周赛-37</title>
    <url>/2020/10/18/leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B-37/</url>
    <content><![CDATA[<p>这次周赛的后两题挺有意思的，<del>但是我一个也没写出来，哭</del>  记录一下解法</p>
<h2 id="A-删除某些元素后的数组均值"><a href="#A-删除某些元素后的数组均值" class="headerlink" title="A.删除某些元素后的数组均值"></a>A.<a href="https://leetcode-cn.com/problems/mean-of-array-after-removing-some-elements/">删除某些元素后的数组均值</a></h2><p>签到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">trimMean</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=arr.size()/<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;arr.size()-t;i++)ans+=arr[i];</span><br><span class="line">        <span class="keyword">return</span> ans/(arr.size()<span class="number">-2</span>*t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="B-网络信号最好的坐标"><a href="#B-网络信号最好的坐标" class="headerlink" title="B.网络信号最好的坐标"></a>B.<a href="https://leetcode-cn.com/problems/coordinate-with-maximum-network-quality/">网络信号最好的坐标</a></h2><p>暴力枚举被覆盖的所有点，对这些点按照信号大小和位置排序就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,y,sig;</span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">        Node(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,<span class="keyword">int</span> ss)&#123;</span><br><span class="line">            x=xx;y=yy;sig=ss;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node nd)<span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sig==nd.sig)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==nd.x)<span class="keyword">return</span> y&lt;nd.y;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> x&lt;nd.x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sig&gt;nd.sig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bestCoordinate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; towers, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt;nd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=-r;i&lt;=<span class="number">50</span>+r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-r;j&lt;=<span class="number">50</span>+r;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;towers.size();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dis(i,j,towers[k][<span class="number">0</span>],towers[k][<span class="number">1</span>])&lt;=r)&#123;</span><br><span class="line">                        sum+=towers[k][<span class="number">2</span>]/(dis(i,j,towers[k][<span class="number">0</span>],towers[k][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nd.push_back(Node(i,j,sum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nd.begin(),nd.end());</span><br><span class="line">        <span class="keyword">return</span> &#123;nd[<span class="number">0</span>].x,nd[<span class="number">0</span>].y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="C-大小为-K-的不重叠线段的数目"><a href="#C-大小为-K-的不重叠线段的数目" class="headerlink" title="C.大小为 K 的不重叠线段的数目"></a>C.<a href="https://leetcode-cn.com/problems/number-of-sets-of-k-non-overlapping-line-segments/">大小为 K 的不重叠线段的数目</a></h2><img src="/2020/10/18/leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B-37/C.png" class="">
<p>这题我一开始用dp[i][j]表示k个线段覆盖n个点的方案数，结果到最后也没有找到转移方程，赛后才发现状态表示少了一个维度。正确的状态定义如下</p>
<ul>
<li>f[n][k]表示用k条线段覆盖0,1,…n这些点，并且点n没有被第k条线段的右端点覆盖的方案数</li>
<li>g[n][k]表示用k条线段覆盖n个点，且点n被第k条线段的右端点覆盖了的方案数。</li>
</ul>
<p>对于f[i][j],由于第i个点没有被覆盖，因此它应该等于前i-1个点被k条线段覆盖的方案数，即</p>
<script type="math/tex; mode=display">
f[i][j]=f[i-1][j]+g[i-1][j]</script><p>而对于g[i][j],可分为两种情况：</p>
<ul>
<li><p>第j条线段长度为1，这种情况下g[i][j]应该等于前i-1个点被k-1条线段覆盖的方案数，即</p>
<script type="math/tex; mode=display">
g[i][j]=f[i-1][j-1]+g[i-1][j-1]</script></li>
<li><p>第j条线段长度大于1，也就是说第i-1个点必须被覆盖，那么这种情况下有</p>
<script type="math/tex; mode=display">
g[i][j]=g[i-1][j]</script></li>
</ul>
<p>最后的答案即为f[n-1][k]+g[n-1][k]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSets</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f[][]=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> g[][]=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=Math.min(k,i);j++)&#123;</span><br><span class="line">                f[i][j]=(f[i<span class="number">-1</span>][j]+g[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">                g[i][j]=g[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    g[i][j]=(g[i][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">                    g[i][j]=(g[i][j]+g[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][k];<span class="comment">//f[n][k]=f[n-1][k]+g[n-1][k]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有一种神奇的组合数学解法：</p>
<p>题目等价于求满足</p>
<script type="math/tex; mode=display">
0<=l_1<r_1<=l_2<r2<=\cdots<=l_k<r_k<n</script><p>的$(l_1,\cdots,l_k,r_1,\cdots,r_k)$的方案数，令$l’_i = l_i + (i-1),r’_i = r_i + (i-1)$,那么得到的$(l’_1,\cdots,l’_k,r’_1,\cdots,r’_k)$与$(l_1,\cdots,l_k,r_1,\cdots,r_k)$是逐一对应的，并且满足</p>
<script type="math/tex; mode=display">
0<=l_1<r_1<l_2<r2<\cdots<l_k<r_k<n+k-1</script><p>由于$(l’_1,\cdots,l’_k,r’_1,\cdots,r’_k)$与$(l_1,\cdots,l_k,r_1,\cdots,r_k)$可以一一对应，所以他们的方案数也应该是相同的，所以答案等于在n+k-1个数中任选$2k$个的方案数，最终答案为</p>
<script type="math/tex; mode=display">
\left(\matrix{n+k-1\\2k}\right)</script><h2 id="D-奇妙序列"><a href="#D-奇妙序列" class="headerlink" title="D.奇妙序列"></a>D.<a href="https://leetcode-cn.com/problems/fancy-sequence/">奇妙序列</a></h2><img src="/2020/10/18/leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B-37/D.png" class="">
<p>这题用线段树是可以做的，但是由于每次更新操作都是对当前的整个序列（对于最终的序列a来说，则是每次对a的前缀）进行操作，所以可以用更简洁的做法来解决。</p>
<p>具体做法是维护两个标记add和mul。当序列需要进行更新操作时，并不对整个序列做更新，而是只更新这两个标记（类似线段树的lazy标记），当遇到对a[i]的查询操作时，返回值为a[i]*mul+add。</p>
<p>但是这样还有一个问题：当一个新的元素x插入进来时，如果直接将他存到数组a中，查询时会得到错误的结果，因为add和mul中还记录了x插入之前的更新信息。因此，为了保持这两个标记对这个新元素x的正确性，我们需要在插入之前先对x先做一下逆操作，即令</p>
<script type="math/tex; mode=display">
y=(x-add)/mul=(x-add)*inv(mul),</script><p>然后将y存入数组a中，这样在查询的时候我们才能得到正确的x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fancy</span> &#123;</span></span><br><span class="line">    List&lt;Long&gt; a;</span><br><span class="line">    <span class="keyword">long</span> add=<span class="number">0</span>,mul=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> mod=<span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)&gt;<span class="number">0</span>)ans=ans*a%mod;</span><br><span class="line">            a=a*a%mod;</span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fancy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a=<span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> t=qpow(mul,mod<span class="number">-2</span>,mod);</span><br><span class="line">        <span class="keyword">long</span> val=v;</span><br><span class="line">        val=((val-add)%mod+mod)%mod;</span><br><span class="line">        val=val*t%mod;</span><br><span class="line">        a.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> inc)</span> </span>&#123;</span><br><span class="line">        add=(add+inc)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multAll</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        add=add*m%mod;</span><br><span class="line">        mul=mul*m%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=a.size())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((a.get(idx)*mul+add)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Fancy object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Fancy obj = new Fancy();</span></span><br><span class="line"><span class="comment"> * obj.append(val);</span></span><br><span class="line"><span class="comment"> * obj.addAll(inc);</span></span><br><span class="line"><span class="comment"> * obj.multAll(m);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getIndex(idx);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>组合数学</tag>
        <tag>算法</tag>
        <tag>双周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛-211</title>
    <url>/2020/10/19/leetcode%E5%91%A8%E8%B5%9B-211/</url>
    <content><![CDATA[<p>这场睡过头了没有打，补一下</p>
<h2 id="A-两个相同字符之间的最长子字符串"><a href="#A-两个相同字符之间的最长子字符串" class="headerlink" title="A.两个相同字符之间的最长子字符串"></a>A.<a href="https://leetcode-cn.com/problems/largest-substring-between-two-equal-characters/">两个相同字符之间的最长子字符串</a></h2><p>签到题还Wa了一发</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLengthBetweenEqualCharacters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.count(s[i])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ans=max(ans,i-mp[s[i]]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mp[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="B-执行操作后字典序最小的字符串"><a href="#B-执行操作后字典序最小的字符串" class="headerlink" title="B.执行操作后字典序最小的字符串"></a>B.<a href="https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations/">执行操作后字典序最小的字符串</a></h2><p><img src="leetcode周赛-211\B.png" alt="image-20201019131747312" style="zoom: 67%;" /></p>
<p>注意到所有奇数位同步变化，所有偶数位同步变化，所以可以直接枚举最终状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLexSmallestString</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> g=gcd(n,b);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;vec;</span><br><span class="line">        <span class="built_in">string</span> s2=s+s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=g)&#123;</span><br><span class="line">            vec.push_back(s2.substr(i,n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans=s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(g%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">10</span>);<span class="comment">//当g为偶数时，偶数位和奇数位不能互换，因此偶数位不会发生变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> str:vec)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;n;k+=<span class="number">2</span>)str[k]=(str[k]-<span class="string">&#x27;0&#x27;</span>+i*a)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k+=<span class="number">2</span>)str[k]=(str[k]-<span class="string">&#x27;0&#x27;</span>+j*a)%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    ans=min(ans,str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="C-无矛盾的最佳球队"><a href="#C-无矛盾的最佳球队" class="headerlink" title="C.无矛盾的最佳球队"></a>C.<a href="https://leetcode-cn.com/problems/best-team-with-no-conflicts/">无矛盾的最佳球队</a></h2><p><img src="leetcode周赛-211\C.png" alt="image-20201019132903740" style="zoom:80%;" /></p>
<p>首先对每个球员按照年龄升序排序，dp[i][j]表示在前i个人中选择了第j个人的情况下的最高得分，然后容易得到递推式和最终结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> age,sco;</span><br><span class="line">        Node()&#123;&#125;</span><br><span class="line">        Node(<span class="keyword">int</span> a,<span class="keyword">int</span> s)&#123;</span><br><span class="line">            age=a;sco=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node nd)<span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(age==nd.age)<span class="keyword">return</span> sco&lt;nd.sco;</span><br><span class="line">            <span class="keyword">return</span> age&lt;nd.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestTeamScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; scores, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt;nd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;scores.size();i++)nd.push_back(Node(ages[i],scores[i]));</span><br><span class="line">        sort(nd.begin(),nd.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(nd.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nd.size();i++)&#123;</span><br><span class="line">            dp[i]=nd[i].sco;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nd[j].sco&gt;nd[i].sco)<span class="keyword">continue</span>;</span><br><span class="line">                dp[i]=max(dp[i],dp[j]+nd[i].sco);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="D-带阈值的图连通性"><a href="#D-带阈值的图连通性" class="headerlink" title="D.带阈值的图连通性"></a>D.<a href="https://leetcode-cn.com/problems/graph-connectivity-with-threshold/">带阈值的图连通性</a></h2><p><img src="leetcode周赛-211\D.png" alt="image-20201019133651772" style="zoom:80%;" /></p>
<p>直接查询会超时，用并查集预处理一下就好了（不带路径压缩还是会超时）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;eg;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;fa;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=x;</span><br><span class="line">        <span class="keyword">while</span>(res!=fa[res])res=fa[res];</span><br><span class="line">        <span class="keyword">return</span> fa[x]=res;<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">areConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> th, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; que)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;ans;</span><br><span class="line">        eg.clear();</span><br><span class="line">        fa.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=th+<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=n;j+=i)&#123;</span><br><span class="line">                eg.push_back(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fa.resize(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:eg)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=find(e.first),y=find(e.second);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">                fa[x]=y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> q:que)&#123;</span><br><span class="line">            ans.push_back(find(q[<span class="number">0</span>])==find(q[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>枚举</tag>
        <tag>DP</tag>
        <tag>并查集</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
</search>
